<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmsr: msr206.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmsr
   &#160;<span id="projectnumber">dc2dc9c</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">msr206.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;strings.h&gt;</code><br />
<code>#include &lt;err.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="libmsr_8h_source.html">libmsr.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for msr206.c:</div>
<div class="dyncontent">
<div class="center"><img src="msr206_8c__incl.png" border="0" usemap="#msr206_8c" alt=""/></div>
<map name="msr206_8c" id="msr206_8c">
<area shape="rect" id="node9" href="libmsr_8h.html" title="libmsr.h" alt="" coords="613,80,681,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a03704956dc06b6881cf337876796bd52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a03704956dc06b6881cf337876796bd52">msr_cmd</a> (int fd, uint8_t c)</td></tr>
<tr class="separator:a03704956dc06b6881cf337876796bd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910cab4ea66f3595792b9c2366a3fd18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a910cab4ea66f3595792b9c2366a3fd18">msr_zeros</a> (int fd, <a class="el" href="libmsr_8h.html#a5b5e194bc0e39dd8e1335156a3ea7691">msr_lz_t</a> *lz)</td></tr>
<tr class="memdesc:a910cab4ea66f3595792b9c2366a3fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MSR device's current leading-zero setting.  <a href="#a910cab4ea66f3595792b9c2366a3fd18">More...</a><br /></td></tr>
<tr class="separator:a910cab4ea66f3595792b9c2366a3fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cbf23ef641d32a6e40af53e61e63b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a57cbf23ef641d32a6e40af53e61e63b0">msr_commtest</a> (int fd)</td></tr>
<tr class="memdesc:a57cbf23ef641d32a6e40af53e61e63b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a communications test.  <a href="#a57cbf23ef641d32a6e40af53e61e63b0">More...</a><br /></td></tr>
<tr class="separator:a57cbf23ef641d32a6e40af53e61e63b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b0140201a7e2260978fa560e5c68c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a5a2b0140201a7e2260978fa560e5c68c">msr_fwrev</a> (int fd, uint8_t *buf)</td></tr>
<tr class="memdesc:a5a2b0140201a7e2260978fa560e5c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the device's firmware revision.  <a href="#a5a2b0140201a7e2260978fa560e5c68c">More...</a><br /></td></tr>
<tr class="separator:a5a2b0140201a7e2260978fa560e5c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ece20ca62fbe8ad5ec7e2b3db77665"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#ad1ece20ca62fbe8ad5ec7e2b3db77665">msr_model</a> (int fd, uint8_t *buf)</td></tr>
<tr class="memdesc:ad1ece20ca62fbe8ad5ec7e2b3db77665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the device's model.  <a href="#ad1ece20ca62fbe8ad5ec7e2b3db77665">More...</a><br /></td></tr>
<tr class="separator:ad1ece20ca62fbe8ad5ec7e2b3db77665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c970831fee41f0fd5f7d56760b228d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a39c970831fee41f0fd5f7d56760b228d">msr_flash_led</a> (int fd, uint8_t led)</td></tr>
<tr class="memdesc:a39c970831fee41f0fd5f7d56760b228d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the LEDs on the MSR device.  <a href="#a39c970831fee41f0fd5f7d56760b228d">More...</a><br /></td></tr>
<tr class="separator:a39c970831fee41f0fd5f7d56760b228d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3805efb042480e3d825785f580e8779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#ab3805efb042480e3d825785f580e8779">msr_sensor_test</a> (int fd)</td></tr>
<tr class="memdesc:ab3805efb042480e3d825785f580e8779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the device's sensor.  <a href="#ab3805efb042480e3d825785f580e8779">More...</a><br /></td></tr>
<tr class="separator:ab3805efb042480e3d825785f580e8779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1738785949edbc8c45e9f295d8e42a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a7c1738785949edbc8c45e9f295d8e42a">msr_ram_test</a> (int fd)</td></tr>
<tr class="memdesc:a7c1738785949edbc8c45e9f295d8e42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the device's RAM.  <a href="#a7c1738785949edbc8c45e9f295d8e42a">More...</a><br /></td></tr>
<tr class="separator:a7c1738785949edbc8c45e9f295d8e42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e2b8ce747849697514b94f5091c5c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#ac3e2b8ce747849697514b94f5091c5c5">msr_get_co</a> (int fd)</td></tr>
<tr class="memdesc:ac3e2b8ce747849697514b94f5091c5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device's coercivity level.  <a href="#ac3e2b8ce747849697514b94f5091c5c5">More...</a><br /></td></tr>
<tr class="separator:ac3e2b8ce747849697514b94f5091c5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e806d45cc3179892a4e371d58a7790"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a53e806d45cc3179892a4e371d58a7790">msr_set_hi_co</a> (int fd)</td></tr>
<tr class="memdesc:a53e806d45cc3179892a4e371d58a7790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device's coercivity to high.  <a href="#a53e806d45cc3179892a4e371d58a7790">More...</a><br /></td></tr>
<tr class="separator:a53e806d45cc3179892a4e371d58a7790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746ac1fa551ed929348f187eb057ca67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a746ac1fa551ed929348f187eb057ca67">msr_set_lo_co</a> (int fd)</td></tr>
<tr class="memdesc:a746ac1fa551ed929348f187eb057ca67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device's coercivity to low.  <a href="#a746ac1fa551ed929348f187eb057ca67">More...</a><br /></td></tr>
<tr class="separator:a746ac1fa551ed929348f187eb057ca67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9aced603ffaee134ba02df401ee5dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a7a9aced603ffaee134ba02df401ee5dd">msr_reset</a> (int fd)</td></tr>
<tr class="memdesc:a7a9aced603ffaee134ba02df401ee5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the MSR device.  <a href="#a7a9aced603ffaee134ba02df401ee5dd">More...</a><br /></td></tr>
<tr class="separator:a7a9aced603ffaee134ba02df401ee5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c021c487a9c7e63d8bc892dd2c25c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a03c021c487a9c7e63d8bc892dd2c25c3">msr_iso_read</a> (int fd, <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *tracks)</td></tr>
<tr class="memdesc:a03c021c487a9c7e63d8bc892dd2c25c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an ISO formatted card.  <a href="#a03c021c487a9c7e63d8bc892dd2c25c3">More...</a><br /></td></tr>
<tr class="separator:a03c021c487a9c7e63d8bc892dd2c25c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6c4451d51f815489280011c26d5f0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#abd6c4451d51f815489280011c26d5f0f">msr_erase</a> (int fd, uint8_t tracks)</td></tr>
<tr class="memdesc:abd6c4451d51f815489280011c26d5f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase one or more tracks on a card.  <a href="#abd6c4451d51f815489280011c26d5f0f">More...</a><br /></td></tr>
<tr class="separator:abd6c4451d51f815489280011c26d5f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134a2a095b9bc605fe23f71a9df5ab63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a134a2a095b9bc605fe23f71a9df5ab63">msr_iso_write</a> (int fd, <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *tracks)</td></tr>
<tr class="memdesc:a134a2a095b9bc605fe23f71a9df5ab63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an ISO formatted card.  <a href="#a134a2a095b9bc605fe23f71a9df5ab63">More...</a><br /></td></tr>
<tr class="separator:a134a2a095b9bc605fe23f71a9df5ab63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc56158653dbcf4472f6cfe280f8a614"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#afc56158653dbcf4472f6cfe280f8a614">msr_raw_read</a> (int fd, <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *tracks)</td></tr>
<tr class="memdesc:afc56158653dbcf4472f6cfe280f8a614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read raw data from a card.  <a href="#afc56158653dbcf4472f6cfe280f8a614">More...</a><br /></td></tr>
<tr class="separator:afc56158653dbcf4472f6cfe280f8a614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d039c0ccac0b57a8fff150994b248e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a8d039c0ccac0b57a8fff150994b248e0">msr_raw_write</a> (int fd, <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *tracks)</td></tr>
<tr class="memdesc:a8d039c0ccac0b57a8fff150994b248e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write raw data to a card.  <a href="#a8d039c0ccac0b57a8fff150994b248e0">More...</a><br /></td></tr>
<tr class="separator:a8d039c0ccac0b57a8fff150994b248e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a18139419069e04faca423b53d7614"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a76a18139419069e04faca423b53d7614">msr_init</a> (int fd)</td></tr>
<tr class="memdesc:a76a18139419069e04faca423b53d7614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the MSR device.  <a href="#a76a18139419069e04faca423b53d7614">More...</a><br /></td></tr>
<tr class="separator:a76a18139419069e04faca423b53d7614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cd1db59de4b2e526e1531cef84d90b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a31cd1db59de4b2e526e1531cef84d90b">msr_set_bpi</a> (int fd, uint8_t bpi)</td></tr>
<tr class="memdesc:a31cd1db59de4b2e526e1531cef84d90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MSR device's BPI value.  <a href="#a31cd1db59de4b2e526e1531cef84d90b">More...</a><br /></td></tr>
<tr class="separator:a31cd1db59de4b2e526e1531cef84d90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1276f965cab98561e41cbeb7c7f21159"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msr206_8c.html#a1276f965cab98561e41cbeb7c7f21159">msr_set_bpc</a> (int fd, uint8_t bpc1, uint8_t bpc2, uint8_t bpc3)</td></tr>
<tr class="memdesc:a1276f965cab98561e41cbeb7c7f21159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MSR device's BPC value for each track.  <a href="#a1276f965cab98561e41cbeb7c7f21159">More...</a><br /></td></tr>
<tr class="separator:a1276f965cab98561e41cbeb7c7f21159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a03704956dc06b6881cf337876796bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03704956dc06b6881cf337876796bd52">&#9670;&nbsp;</a></span>msr_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structmsr__cmd.html">msr_cmd</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57cbf23ef641d32a6e40af53e61e63b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cbf23ef641d32a6e40af53e61e63b0">&#9670;&nbsp;</a></span>msr_commtest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_commtest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a communications test. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a39b792b08e6bfb9f128b2e7aeddc9a65">MSR_CMD_DIAG_COMM</a> command to the device to perform a communications diagnostic test. After issuing this command, the device will respond with an <a class="el" href="libmsr_8h.html#a540e61ff0a70536c6c5374067c580c1b">MSR_STS_COMM_OK</a> byte if the test passes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#a984cbac8252138abcca709be71c4b1a3">LIBMSR_ERR_SERIAL</a> on serial I/O failure. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="abd6c4451d51f815489280011c26d5f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6c4451d51f815489280011c26d5f0f">&#9670;&nbsp;</a></span>msr_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_erase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tracks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase one or more tracks on a card. </p>
<p>This routine issues an <a class="el" href="libmsr_8h.html#a2ee0a3ed54d0190146c6e3bc01e1a72a">MSR_CMD_ERASE</a> command to the device to read erase a magstripe card. After the command is issued, the user must swipe a card through the MSR206. The function will block until the device returns a response code indicating that the erase operation completed successfully.</p>
<p>This function can erase various combinations of tracks, or erase all of them, depending on the tracks value specified:</p>
<p><a class="el" href="libmsr_8h.html#a439ba577caf7627beb3748abdf3e38e3">MSR_ERASE_TK1</a> erase track 1 only</p>
<p><a class="el" href="libmsr_8h.html#ac7d5dbe2d062e0ea08c0762622622b3b">MSR_ERASE_TK2</a> erase track 2 only</p>
<p><a class="el" href="libmsr_8h.html#a395c0e399f9931e3883bbe9c07e322f8">MSR_ERASE_TK3</a> erase track 3 only</p>
<p><a class="el" href="libmsr_8h.html#a4f2d8e290e991cb15d68f9f76ca8713a">MSR_ERASE_TK1_TK2</a> erase tracks 1 and 2</p>
<p><a class="el" href="libmsr_8h.html#a501441645f813757686eb7b7c0a3581c">MSR_ERASE_TK1_TK3</a> erase tracks 1 and 3</p>
<p><a class="el" href="libmsr_8h.html#a49fef0f536fc2db6be2e8d89d15e5709">MSR_ERASE_TK2_TK3</a> erase tracks 2 and 3</p>
<p><a class="el" href="libmsr_8h.html#a57f08cea91fa266ea596bd3cbe99c8db">MSR_ERASE_ALL</a> erase all tracks</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">tracks</td><td>The tracks to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a39c970831fee41f0fd5f7d56760b228d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c970831fee41f0fd5f7d56760b228d">&#9670;&nbsp;</a></span>msr_flash_led()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_flash_led </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>led</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the LEDs on the MSR device. </p>
<p>This function is used to manually control the LEDs on the MSR206. The device has one green, one yellow and one red LED mounted in it. A given LED is controlled by specifying led as follows:</p>
<p><a class="el" href="libmsr_8h.html#a347e7959864e9444976b1db2fed5cc1b">MSR_CMD_LED_GRN_ON</a> - turn on green LED</p>
<p><a class="el" href="libmsr_8h.html#a71c52c399da5954400171dc1b6272b1e">MSR_CMD_LED_YLW_ON</a> - turn on yellow LED</p>
<p><a class="el" href="libmsr_8h.html#af73931c8f25d193cde0b1ee4ce58455f">MSR_CMD_LED_RED_ON</a> - turn on red LED</p>
<p><a class="el" href="libmsr_8h.html#a252017982c4d745553ee9e49264dc0a4">MSR_CMD_LED_OFF</a> - turn all LEDs off</p>
<p>After an LED control command is issued to the device, the routine will pause for a tenth of a second to allow time for the command to be processed and the LED to light up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">led</td><td>The LED to control. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#a984cbac8252138abcca709be71c4b1a3">LIBMSR_ERR_SERIAL</a> | <a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on error. </dd></dl>

</div>
</div>
<a id="a5a2b0140201a7e2260978fa560e5c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2b0140201a7e2260978fa560e5c68c">&#9670;&nbsp;</a></span>msr_fwrev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_fwrev </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the device's firmware revision. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a3e1e2648b898ec6c71d586af640fd86e">MSR_CMD_FWREV</a> command to the device to retrieve its firmware revision code. The revision is saved in the supplied buffer, which <em>must</em> be at least 9 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to write the revision to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#a984cbac8252138abcca709be71c4b1a3">LIBMSR_ERR_SERIAL</a> on serial I/O failure. </dd></dl>

</div>
</div>
<a id="ac3e2b8ce747849697514b94f5091c5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e2b8ce747849697514b94f5091c5c5">&#9670;&nbsp;</a></span>msr_get_co()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_get_co </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device's coercivity level. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#ade12d5117bcb3c1eba7ff9c0c7c3c470">MSR_CMD_GETCO</a> command to retrieve the device's current coercivity setting, which is either <a class="el" href="libmsr_8h.html#a3f4e06ff205d4c47b3bc4e494204f982">MSR_CO_HI</a> ('H') or <a class="el" href="libmsr_8h.html#aa6c14b9fcff03730932207265b66d1bf">MSR_CO_LO</a> ('L').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a3f4e06ff205d4c47b3bc4e494204f982">MSR_CO_HI</a> if the device is in hi-co mode. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aa6c14b9fcff03730932207265b66d1bf">MSR_CO_LO</a> if the device is in lo-co mode. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a76a18139419069e04faca423b53d7614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a18139419069e04faca423b53d7614">&#9670;&nbsp;</a></span>msr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the MSR device. </p>
<p>This function issues a reset command to the MSR206 device, and then performs a communications diagnostic test. If the test succeeds, another reset is issued to ready the device for a read or write operation. Typically, <a class="el" href="libmsr_8h.html#a76a18139419069e04faca423b53d7614" title="Initialize the MSR device. ">msr_init()</a> must be called before any significant operation, including reading and writing cards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a03c021c487a9c7e63d8bc892dd2c25c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c021c487a9c7e63d8bc892dd2c25c3">&#9670;&nbsp;</a></span>msr_iso_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_iso_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *&#160;</td>
          <td class="paramname"><em>tracks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an ISO formatted card. </p>
<p>This routine issues an <a class="el" href="libmsr_8h.html#abfa0b89d0b3bfa6c4a7d63215c3d5eaf">MSR_CMD_READ</a> command to the device to read an ISO formatted magstripe card. After the command is issued, the user must swipe a card through the MSR206. The function will block until the card is read and the MSR206 is ready to return data from the tracks. The caller must allocate a pointer to an <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> structure and supply a pointer to this structure via the tracks argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">tracks</td><td>A pointer to the <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> to populate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#a984cbac8252138abcca709be71c4b1a3">LIBMSR_ERR_SERIAL</a> on serial I/O failure. </dd></dl>

</div>
</div>
<a id="a134a2a095b9bc605fe23f71a9df5ab63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134a2a095b9bc605fe23f71a9df5ab63">&#9670;&nbsp;</a></span>msr_iso_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_iso_write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *&#160;</td>
          <td class="paramname"><em>tracks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an ISO formatted card. </p>
<p>This routine issues an <a class="el" href="libmsr_8h.html#a5574625bc9b7b0e11c1fcf39283643f7">MSR_CMD_WRITE</a> command to the device to write to an ISO formatted magstripe card. The card does not need to be erased (any existing data is overwritten). The caller must allocate an <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> structure and populate it with the data to be written to the card, then supply a pointer to this structure via the tracks argument. The data in the tracks must meet the ISO requirements.</p>
<p>After the write command is issued and the track data is written to the device, the function will block until a status code is read from the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">tracks</td><td>A pointer to the <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="ad1ece20ca62fbe8ad5ec7e2b3db77665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ece20ca62fbe8ad5ec7e2b3db77665">&#9670;&nbsp;</a></span>msr_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structmsr__model.html">msr_model</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the device's model. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a42ae9d50fa20edadafbfb9b94365f165">MSR_CMD_MODEL</a> command to the device to retrieve its model code. The model code is saved in the supplied buffer, which <em>must</em> be at least 10 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to write the model to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a7c1738785949edbc8c45e9f295d8e42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1738785949edbc8c45e9f295d8e42a">&#9670;&nbsp;</a></span>msr_ram_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_ram_test </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the device's RAM. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a9f022d839e0d15ec72289d2d9fec21f8">MSR_CMD_DIAG_RAM</a> command to perform a diagnostic sense on the MSR206's internal RAM. If the RAM checks good, the device will return a status code of <a class="el" href="libmsr_8h.html#a45959d6aecb582778cab39788cea2ca6">MSR_STS_RAM_OK</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="afc56158653dbcf4472f6cfe280f8a614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc56158653dbcf4472f6cfe280f8a614">&#9670;&nbsp;</a></span>msr_raw_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_raw_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *&#160;</td>
          <td class="paramname"><em>tracks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read raw data from a card. </p>
<p>This routine issues an <a class="el" href="libmsr_8h.html#ae9b1fbaf07792c3fa0dae6882b5ba797">MSR_CMD_RAW_READ</a> command to the device to read arbitrary data from 3 tracks on a magstripe card. After the command is issued, the user must swipe a card through the MSR206. The function will block until the card is read and the MSR206 is ready to return data from the tracks. The caller must allocate a pointer to an <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> structure and supply a pointer to this structure via the tracks argument.</p>
<p>Unlike the <a class="el" href="libmsr_8h.html#a03c021c487a9c7e63d8bc892dd2c25c3" title="Read an ISO formatted card. ">msr_iso_read()</a> function, this routine bypasses the MSR206's internal data parser and returns data representing the raw bit pattern on the magnetic media. It is up to the caller to decode this data into a useful form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">tracks</td><td>A pointer to the <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> to populate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a8d039c0ccac0b57a8fff150994b248e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d039c0ccac0b57a8fff150994b248e0">&#9670;&nbsp;</a></span>msr_raw_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_raw_write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa">msr_tracks_t</a> *&#160;</td>
          <td class="paramname"><em>tracks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write raw data to a card. </p>
<p>This routine issues an <a class="el" href="libmsr_8h.html#ae48f92cbaeeea534115182c10d9ea44d">MSR_CMD_RAW_WRITE</a> command to the device to write arbitrary data to a magstripe card. The card does not need to be erased (any existing data is overwritten). The caller must allocate an <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> structure and populate it with the data to be written to the card, then supply a pointer to this structure via the tracks argument. The data can be in any format.</p>
<p>After the write command is issued and the track data is written to the device, the function will block until a status code is read from the device.</p>
<p>Unlike the <a class="el" href="libmsr_8h.html#a134a2a095b9bc605fe23f71a9df5ab63" title="Write an ISO formatted card. ">msr_iso_write()</a> routine, this function bypasses the MSR206's internal parser and writes the bit pattern represented by the track data unmodified to the card. It's up to the caller to format the data in a meaningful way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">tracks</td><td>A pointer to the <a class="el" href="libmsr_8h.html#a211b9ddf7564b1885baadbcf2bae08fa" title="Represents all tracks on a magnetic card. ">msr_tracks_t</a> data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a7a9aced603ffaee134ba02df401ee5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9aced603ffaee134ba02df401ee5dd">&#9670;&nbsp;</a></span>msr_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_reset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the MSR device. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a876b2541d06af7fd5526f292309e45f7">MSR_CMD_RESET</a> command to reset the device. This command does not return a status code. The routine pauses for a tenth of a second to wait for the reset to complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a>. </dd></dl>

</div>
</div>
<a id="ab3805efb042480e3d825785f580e8779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3805efb042480e3d825785f580e8779">&#9670;&nbsp;</a></span>msr_sensor_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_sensor_test </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the device's sensor. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a909d076ed353e9f478118511f4612e3b">MSR_CMD_DIAG_SENSOR</a> command to perform a diagnostic sense on the mechanical card sensor in the MSR206. After issuing the command, the user is instructed to slide a card through the reader. No actual read is performed, however the hardware tests to verify that the card sensor registers the presence of the card in the track. If the card registers correctly, the device will return a status code of <a class="el" href="libmsr_8h.html#a391dbd32fe60c865b12fbe86c624a301">MSR_STS_SENSOR_OK</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a1276f965cab98561e41cbeb7c7f21159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1276f965cab98561e41cbeb7c7f21159">&#9670;&nbsp;</a></span>msr_set_bpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_set_bpc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bpc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bpc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bpc3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MSR device's BPC value for each track. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#aaf1e62b72070be830cc5719a914830d4">MSR_CMD_SETBPC</a> command to bits per character configuration for all 3 tracks. (This command has no effect for other tracks.) It is assumed that this command only has meaning when using ISO read or write commands. The MSR206 supports writing data with BPC values from 5 to 8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">bpc1</td><td>The new BPC value for track 1. </td></tr>
    <tr><td class="paramname">bpc2</td><td>The new BPC value for track 2. </td></tr>
    <tr><td class="paramname">bpc3</td><td>The new BPC value for track 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a31cd1db59de4b2e526e1531cef84d90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cd1db59de4b2e526e1531cef84d90b">&#9670;&nbsp;</a></span>msr_set_bpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_set_bpi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bpi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MSR device's BPI value. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#a631da5bdfd607e2caf5abea2d22335bf">MSR_CMD_SETBPI</a> command to set the bits per inch configuration for track 2. (This command has no effect for other tracks.) It is assumed that this command only has meaning when writing data. The MSR206 supports writing data on track 2 with bpi values. Valid options are either 75 or 210 bits per inch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">bpi</td><td>The new BPI value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a53e806d45cc3179892a4e371d58a7790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e806d45cc3179892a4e371d58a7790">&#9670;&nbsp;</a></span>msr_set_hi_co()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_set_hi_co </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the device's coercivity to high. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#abd686d97716b1d2c19039875c6979a0f">MSR_CMD_SETCO_HI</a> command to switch the device to high coercivity mode. It is unclear if this affects both the read and write operations, though presumably it only affects writes by channeling more power to the write head so that it can update high-coercivity media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a746ac1fa551ed929348f187eb057ca67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746ac1fa551ed929348f187eb057ca67">&#9670;&nbsp;</a></span>msr_set_lo_co()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_set_lo_co </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the device's coercivity to low. </p>
<p>This function issues an <a class="el" href="libmsr_8h.html#aa69315286a099da574d6e06038cb1e24">MSR_CMD_SETCO_LO</a> command to switch the device to low coercivity mode. It is unclear if this affects both the read and write operations, though presumably it only affects writes by channeling less power to the write head so that it can update low-coercivity media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> on success. </dd>
<dd>
<a class="el" href="libmsr_8h.html#aaf42fb1c33f23e7558fd58f1d01742b6">LIBMSR_ERR_DEVICE</a> on device failure. </dd></dl>

</div>
</div>
<a id="a910cab4ea66f3595792b9c2366a3fd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910cab4ea66f3595792b9c2366a3fd18">&#9670;&nbsp;</a></span>msr_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_zeros </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmsr_8h.html#a5b5e194bc0e39dd8e1335156a3ea7691">msr_lz_t</a> *&#160;</td>
          <td class="paramname"><em>lz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MSR device's current leading-zero setting. </p>
<p>The leading-zero setting is used by the device to determine how many leading zeros to write when writing ISO-formatted tracks. There are two values to the setting: one for tracks 1 and 3, and one for track 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The device's fd. </td></tr>
    <tr><td class="paramname">lz</td><td>A pointer to the <a class="el" href="libmsr_8h.html#a5b5e194bc0e39dd8e1335156a3ea7691" title="Represents leading zero counts on a card. ">msr_lz_t</a> to populate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libmsr_8h.html#a407290e96d83ca2a791a7bf3286f089f">LIBMSR_ERR_OK</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
